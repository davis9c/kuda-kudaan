<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Knight's Tour 5×5 — Clustered Generator & Viewer</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    body { padding: 20px; }
    .grid { display: grid; grid-template-columns: repeat(5, 56px); gap:6px; }
    .cell { width:56px; height:56px; display:flex; align-items:center; justify-content:center;
           border:1px solid #666; border-radius:6px; font-weight:700; background:#f8f9fa; }
    .thumb { display:inline-grid; grid-template-columns: repeat(5, 16px); gap:2px; }
    .thumb .cell { width:16px; height:16px; font-size:8px; border-radius:3px; padding:0; display:flex; align-items:center; justify-content:center; }
    .route-item { cursor:pointer; }
    .screenshot { max-width:260px; border:1px solid #ddd; border-radius:6px; }
    .spinner { width:1.2rem; height:1.2rem; border-width: .2rem; }
    .muted-small { font-size:0.85rem; color:#666; }
    .badge-count { font-size:0.75rem; }
  </style>
</head>
<body>
  <div class="container">
    <div class="d-flex align-items-start mb-3">
      <div class="me-auto">
        <h3>Knight's Tour 5×5 — Clustered Generator & Viewer</h3>
        <div class="muted-small">Generator berjalan di browser menggunakan Warnsdorff-ordered backtracking + canonicalisasi D8. Pilih kelompok, pilih rute, lihat pola 5×5.</div>
      </div>
      <div class="ms-3 text-end">
        <img src="/mnt/data/361951fb-d8cd-442c-89ab-e36ad2c72116.png" alt="screenshot" class="screenshot">
        <div class="muted-small mt-1">Contoh screenshot</div>
      </div>
    </div>

    <div class="row g-3">
      <div class="col-md-4">
        <div class="card p-3 mb-3">
          <div class="mb-2">
            <label class="form-label">Kelompok Formasi</label>
            <select id="groupSelect" class="form-select">
              <option value="">-- Pilih kelompok --</option>
              <option value="corner">Corner (sudut)</option>
              <option value="mid_edge">Mid-edge (tepi tengah)</option>
              <option value="mid_corner">Mid-corner (dekat sudut)</option>
              <option value="center">Center (tengah)</option>
            </select>
          </div>

          <div class="mb-2">
            <button id="generateBtn" class="btn btn-primary w-100">Generate Semua Formasi (di browser)</button>
          </div>

          <div class="mb-2">
            <div id="progressArea" style="min-height:34px;">
              <div id="statusText" class="muted-small">Belum digenerate.</div>
            </div>
          </div>

          <div id="routeList" class="list-group" style="max-height:520px; overflow:auto;"></div>
        </div>

        <div class="muted-small">Catatan: setelah generate selesai, Anda dapat memilih kelompok dan rute, lalu klik <b>Download JSON</b> untuk menyimpan hasil.</div>
      </div>

      <div class="col-md-8">
        <div class="card p-3">
          <div class="d-flex mb-2 align-items-center">
            <h5 id="routeTitle" class="me-auto">Pilih rute...</h5>
            <div id="countsTag" class="text-end muted-small"></div>
          </div>

          <div id="grid" class="grid mb-3"></div>

          <div class="d-flex gap-2">
            <button id="prevBtn" class="btn btn-outline-primary" disabled>Prev</button>
            <button id="nextBtn" class="btn btn-outline-primary" disabled>Next</button>
            <button id="downloadBtn" class="btn btn-success ms-auto" disabled>Download JSON</button>
          </div>

        </div>
      </div>
    </div>

    <footer class="mt-3 text-muted">Built: local browser generator</footer>
  </div>

<script>
/*
  Client-side generator + viewer.

  - Generates all knight's tours on 5x5 using Warnsdorff-ordered backtracking.
  - Canonicalizes with 8 dihedral transforms to eliminate symmetries.
  - Clusters into 4 groups: corner, mid_edge, mid_corner, center.
  - Renders UI with Bootstrap.
*/

(() => {
  const N = 5;
  const moves = [[2,1],[1,2],[-1,2],[-2,1],[-2,-1],[-1,-2],[1,-2],[2,-1]];
  const neighbors = {};
  for (let x=0;x<N;x++){
    for (let y=0;y<N;y++){
      const key = `${x},${y}`;
      neighbors[key] = [];
      for (const [dx,dy] of moves) {
        const nx = x+dx, ny = y+dy;
        if (nx>=0 && nx<N && ny>=0 && ny<N) neighbors[key].push([nx,ny]);
      }
    }
  }

  // dihedral transforms: 8 functions mapping (x,y) -> (nx,ny)
  function transformPoint(x,y, t) {
    if (t===0) return [x,y];
    if (t===1) return [y, N-1-x];
    if (t===2) return [N-1-x, N-1-y];
    if (t===3) return [N-1-y, x];
    if (t===4) return [x, N-1-y];
    if (t===5) return [N-1-y, N-1-x];
    if (t===6) return [N-1-x, y];
    if (t===7) return [y, x];
    return [x,y];
  }

  function canonicalKey(tour) {
    // tour: array of [x,y] length 25
    let best = null;
    for (let t=0;t<8;t++){
      const flat = [];
      for (let i=0;i<tour.length;i++){
        const [x,y] = tour[i];
        const [nx,ny] = transformPoint(x,y,t);
        flat.push(nx,ny);
      }
      const s = flat.join(',');
      if (best===null || s < best) best = s;
    }
    return best;
  }

  // Warnsdorff onward degree
  function onwardDegree(x,y, visited) {
    let cnt = 0;
    for (const [nx,ny] of neighbors[`${x},${y}`]) {
      if (!visited[nx][ny]) cnt++;
    }
    return cnt;
  }

  // classify group by starting square (1-index)
  function classifyTour(tour) {
    const [x0,y0] = tour[0];
    const r = x0+1, c = y0+1;
    const corner = [[1,1],[1,5],[5,1],[5,5]].map(x=>x.join(','));
    const mid_edge = [[1,3],[3,1],[3,5],[5,3]].map(x=>x.join(','));
    const mid_corner = [[2,2],[2,4],[4,2],[4,4]].map(x=>x.join(','));
    if (corner.includes([r,c].join(','))) return 'corner';
    if (mid_edge.includes([r,c].join(','))) return 'mid_edge';
    if (mid_corner.includes([r,c].join(','))) return 'mid_corner';
    if (r===3 && c===3) return 'center';
    return 'other';
  }

  // build matrix 5x5 from tour
  function tourToMatrix(tour) {
    const mat = Array.from({length:N}, ()=>Array.from({length:N}, ()=>0));
    for (let i=0;i<tour.length;i++){
      const [x,y] = tour[i];
      mat[x][y] = i+1;
    }
    return mat;
  }

  // DOM elements
  const generateBtn = document.getElementById('generateBtn');
  const statusText = document.getElementById('statusText');
  const groupSelect = document.getElementById('groupSelect');
  const routeList = document.getElementById('routeList');
  const routeTitle = document.getElementById('routeTitle');
  const grid = document.getElementById('grid');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const countsTag = document.getElementById('countsTag');

  let groups = {corner:[], mid_edge:[], mid_corner:[], center:[]};
  let canonicalSet = new Set();
  let currentGroup = null, currentIndex = 0;

  function renderGrid(mat) {
    grid.innerHTML = '';
    for (let i=0;i<N;i++){
      for (let j=0;j<N;j++){
        const d = document.createElement('div');
        d.className = 'cell';
        d.textContent = mat[i][j] || '';
        grid.appendChild(d);
      }
    }
  }

  function buildRouteList(key) {
    routeList.innerHTML = '';
    if (!groups[key]) return;
    groups[key].forEach((entry, idx) => {
      const a = document.createElement('a');
      a.href = '#';
      a.className = 'list-group-item list-group-item-action d-flex justify-content-between align-items-center route-item';
      a.dataset.idx = idx;
      a.innerHTML = `<div>Rute ${entry.id}</div><div class="thumb"></div>`;
      const thumb = a.querySelector('.thumb');
      for (let i=0;i<N;i++){
        for (let j=0;j<N;j++){
          const c = document.createElement('div');
          c.className = 'cell';
          c.style.fontSize='6px';
          c.style.width='16px';
          c.style.height='16px';
          c.style.padding='0';
          c.style.border='1px solid #ccc';
          c.style.background='#fff';
          const v = entry.matrix[i][j];
          c.textContent = v>0?Math.min(9,v):'';
          thumb.appendChild(c);
        }
      }
      a.addEventListener('click', (ev) => {
        ev.preventDefault();
        currentGroup = key;
        currentIndex = idx;
        showRoute(key, idx);
      });
      routeList.appendChild(a);
    });
  }

  function showRoute(key, idx) {
    const entry = groups[key][idx];
    routeTitle.textContent = `Kelompok: ${key} — Rute ${entry.id}`;
    renderGrid(entry.matrix);
    prevBtn.disabled = (idx<=0);
    nextBtn.disabled = (idx >= groups[key].length-1);
  }

  prevBtn.addEventListener('click', ()=> {
    if (!currentGroup) return;
    if (currentIndex>0){ currentIndex--; showRoute(currentGroup, currentIndex); }
  });
  nextBtn.addEventListener('click', ()=> {
    if (!currentGroup) return;
    if (currentIndex < groups[currentGroup].length-1){ currentIndex++; showRoute(currentGroup, currentIndex); }
  });

  downloadBtn.addEventListener('click', ()=> {
    const data = JSON.stringify(groups, null, 2);
    const blob = new Blob([data], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'knight5x5_clustered_480.json';
    a.click();
  });

  groupSelect.addEventListener('change', (ev) => {
    const key = ev.target.value;
    if (!key) return;
    if (groups[key].length===0) {
      routeList.innerHTML = '<div class="p-2 text-muted">Belum ada rute (silakan klik Generate).</div>';
      countsTag.textContent = '';
      return;
    }
    buildRouteList(key);
    countsTag.textContent = `${groups[key].length} rute`;
  });

  // generator engine using async chunks (to keep UI responsive)
  generateBtn.addEventListener('click', async () => {
    generateBtn.disabled = true;
    statusText.textContent = 'Memulai generasi...';
    canonicalSet = new Set();
    groups = {corner:[], mid_edge:[], mid_corner:[], center:[]};
    let idCounters = {corner:0, mid_edge:0, mid_corner:0, center:0};

    // visited as array, tour as array
    let visited = Array.from({length:N}, ()=>Array.from({length:N}, ()=>false));
    let tour = [];

    // We'll iterate start squares 0..24 and run DFS; use await-yield to allow UI painting
    const starts = [];
    for (let i=0;i<N;i++) for (let j=0;j<N;j++) starts.push([i,j]);

    let totalStarts = starts.length;
    let completedStarts = 0;
    const t0 = performance.now();

    // Use recursion but periodically yield to event loop by wrapping in Promise+setTimeout when deep loops
    async function runFrom(startX, startY) {
      visited = Array.from({length:N}, ()=>Array.from({length:N}, ()=>false));
      tour = [[startX,startY]];
      visited[startX][startY] = true;

      function dfs(x,y,step) {
        if (step === N*N) {
          // canonicalize and store unique
          const key = canonicalKey(tour);
          if (!canonicalSet.has(key)) {
            canonicalSet.add(key);
            // pick representative matrix (tour as-is)
            const grp = classifyTour(tour);
            if (['corner','mid_edge','mid_corner','center'].includes(grp)) {
              idCounters[grp] += 1;
              groups[grp].push({id: idCounters[grp], matrix: tourToMatrix(tour)});
            }
          }
          return;
        }
        // generate candidates with onward degree
        const cands = [];
        for (const [nx,ny] of neighbors[`${x},${y}`]) {
          if (!visited[nx][ny]) {
            cands.push([onwardDegree(nx,ny,visited), nx, ny]);
          }
        }
        cands.sort((a,b)=>a[0]-b[0]);
        for (const [, nx, ny] of cands) {
          visited[nx][ny] = true;
          tour.push([nx,ny]);
          dfs(nx,ny,step+1);
          tour.pop();
          visited[nx][ny] = false;
        }
      }

      dfs(startX, startY, 1);
    }

    // run starts sequentially but yield occasionally
    for (const [sx,sy] of starts) {
      await new Promise((resolve)=> {
        // small timeout to keep UI responsive
        setTimeout(async () => {
          try {
            await runFrom(sx,sy);
          } catch(e) { console.error(e); }
          completedStarts++;
          statusText.textContent = `Memproses start ${completedStarts}/${totalStarts} — unique canonical so far: ${canonicalSet.size}`;
          resolve();
        }, 10);
      });
    }

    const elapsed = ((performance.now() - t0)/1000).toFixed(2);
    statusText.textContent = `Selesai dalam ${elapsed}s — unique canonical tours: ${canonicalSet.size}`;
    // sanity: user expected 480 unique canonical tours
    if (canonicalSet.size !== 480) {
      statusText.innerHTML += `<br><span class="text-warning">Catatan: ditemukan ${canonicalSet.size} rute unik (target umum: 480). Hasil tetap dapat digunakan.</span>`;
    } else {
      statusText.innerHTML += `<br><span class="text-success">Ditemukan 480 rute unik (canonical).</span>`;
    }

    // enable controls
    downloadBtn.disabled = false;
    generateBtn.disabled = false;
    // update counts tag for select (if a group is already chosen)
    if (groupSelect.value) {
      countsTag.textContent = `${groups[groupSelect.value].length} rute`;
      buildRouteList(groupSelect.value);
    }
  });

  // helper functions used in runFrom (duplicate to keep scope local)
  function onwardDegree(x,y, visited) {
    let cnt = 0;
    for (const [nx,ny] of neighbors[`${x},${y}`]) {
      if (!visited[nx][ny]) cnt++;
    }
    return cnt;
  }
  function tourToMatrix(tour) {
    const mat = Array.from({length:N}, ()=>Array.from({length:N}, ()=>0));
    for (let i=0;i<tour.length;i++){
      const [x,y] = tour[i];
      mat[x][y] = i+1;
    }
    return mat;
  }
  function canonicalKey(tour) {
    let best = null;
    for (let t=0;t<8;t++){
      const flat = [];
      for (let i=0;i<tour.length;i++){
        const [x,y] = tour[i];
        const [nx,ny] = transformPoint(x,y,t);
        flat.push(nx,ny);
      }
      const s = flat.join(',');
      if (best===null || s < best) best = s;
    }
    return best;
  }
  function transformPoint(x,y, t) {
    if (t===0) return [x,y];
    if (t===1) return [y, N-1-x];
    if (t===2) return [N-1-x, N-1-y];
    if (t===3) return [N-1-y, x];
    if (t===4) return [x, N-1-y];
    if (t===5) return [N-1-y, N-1-x];
    if (t===6) return [N-1-x, y];
    if (t===7) return [y, x];
    return [x,y];
  }
  function classifyTour(tour) {
    const [x0,y0] = tour[0];
    const r = x0+1, c = y0+1;
    const corner = [[1,1],[1,5],[5,1],[5,5]].map(x=>x.join(','));
    const mid_edge = [[1,3],[3,1],[3,5],[5,3]].map(x=>x.join(','));
    const mid_corner = [[2,2],[2,4],[4,2],[4,4]].map(x=>x.join(','));
    if (corner.includes([r,c].join(','))) return 'corner';
    if (mid_edge.includes([r,c].join(','))) return 'mid_edge';
    if (mid_corner.includes([r,c].join(','))) return 'mid_corner';
    if (r===3 && c===3) return 'center';
    return 'other';
  }

  // Expose a final small helper so user can load groups after generation
  window._knight_groups = groups;

})();
</script>

</body>
</html>
